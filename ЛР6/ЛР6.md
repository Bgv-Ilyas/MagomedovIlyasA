# Лабораторная работа №06: Блокировки и мониторинг

**Дата:** 15.11.2025
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Ильяс Аскерович

## Цель работы
Изучить систему блокировок в PostgreSQL и методы мониторинга активности сервера. Получить практические навыки анализа статистики, диагностики блокировок и взаимоблокировок, использования инструментов мониторинга.

## Теоретическая часть
- **Блокировки:** Механизм, обеспечивающий согласованность данных при параллельном доступе. Бывают разных уровней: объекты, строки, буферы в памяти.
- **Мониторинг:** Набор представлений и функций для отслеживания активности сервера, статистики использования объектов и блокировок.
- **Взаимоблокировка (Deadlock):** Ситуация, когда две или более транзакции ожидают друг друга, освобождения ресурсов.

## Практическая часть

### Модуль 1: Мониторинг активности

#### Задача 1:
```sql
CREATE TABLE monitor_test (id INT);
INSERT INTO monitor_test VALUES (1), (2), (3), (4), (5);
DELETE FROM monitor_test;
ANALYZE monitor_test;
-- Изучение статистики
SELECT schemaname, relname, n_tup_ins, n_tup_del, n_live_tup, n_dead_tup 
FROM pg_stat_all_tables 
WHERE relname = 'monitor_test';
VACUUM;
SELECT schemaname, relname, n_tup_ins, n_tup_del, n_live_tup, n_dead_tup 
FROM pg_stat_all_tables 
WHERE relname = 'monitor_test';
```
```
CREATE TABLE
INSERT 0 5
DELETE 5
ANALYZE

   relname    | n_tup_ins | n_tup_del | n_live_tup | n_dead_tup 
--------------+-----------+-----------+------------+------------
 monitor_test |         5 |         5 |          0 |          5
(1 row)

VACUUM
   relname    | n_tup_ins | n_tup_del | n_live_tup | n_dead_tup 
--------------+-----------+-----------+------------+------------
 monitor_test |         5 |         5 |          0 |          0
(1 row)
```

После `VACUUM` значение `n_dead_tup` станет равным `0`, так как "мертвые" строки были физически удалены, а пространство переиспользовано. Остальная статистика не изменится.
#### Задача 2:

```sql
BEGIN;
UPDATE monitor_test SET id = 10 WHERE id = 1;
BEGIN;
UPDATE monitor_test SET id = 20 WHERE id = 2; -- Захватывает блокировку строки с id=2
UPDATE monitor_test SET id = 30 WHERE id = 2; -- Эта транзакция будет ЖДАТЬ, пока Сессия 2 не завершится
UPDATE monitor_test SET id = 40 WHERE id = 1; -- Эта команда пытается захватить строку id=1, которую держит Сессия 1.
```

```
--Сеанс 1
BEGIN
UPDATE 1

--Сеанс 2
BEGIN
UPDATE 1

--Сеанс 1
UPDATE 1

--Сеанс 2
ERROR:  deadlock detected
DETAIL:  Process 97289 waits for ShareLock on transaction 366333; blocked by process 94625.
Process 94625 waits for ShareLock on transaction 366334; blocked by process 97289.
HINT:  See server log for query details.
CONTEXT:  while updating tuple (0,1) in relation "monitor_test"
```

Проверка логов:
```bash
tail -f /opt/homebrew/var/postgresql@16/log/postgresql-2025-11-15_000000.log
```
```
2025-11-15 13:20:42.866 MSK [97289] ilyas@lab06_db ERROR:  deadlock detected
2025-11-15 13:20:42.866 MSK [97289] ilyas@lab06_db DETAIL:  Process 97289 waits for ShareLock on transaction 366333; blocked by process 94625.
	Process 94625 waits for ShareLock on transaction 366334; blocked by process 97289.
	Process 97289: UPDATE monitor_test SET val=10 WHERE id=1;
	Process 94625: UPDATE monitor_test SET val=20 WHERE id=2;
```
#### Задача 3:
```sql
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
SELECT * FROM monitor_test;
INSERT INTO monitor_test VALUES (100);
DELETE FROM monitor_test WHERE id > 50;
-- Анализ статистики
SELECT query, calls, total_exec_time, mean_exec_time, rows
FROM pg_stat_statements
WHERE query NOT LIKE '%pg_stat%';
```
```
 id 
----
  1
  2
  3
(3 rows)
INSERT 0 1
DELETE 1
                 query                  | calls |   total_exec_time   |   mean_exec_time    | rows 
----------------------------------------+-------+---------------------+---------------------+------
 DELETE FROM monitor_test WHERE id > $1 |     1 |            0.021166 |            0.021166 |    1
 ANALYZE monitor_test                   |     1 |            4.052125 |            4.052125 |    0
 INSERT INTO monitor_test VALUES ($1)   |     1 | 0.28212499999999996 | 0.28212499999999996 |    1
 SELECT * FROM monitor_test             |     1 | 0.17220700000000003 | 0.17220700000000003 |    3
(4 rows)
```

### Модуль 2: Блокировки объектов
#### Задача 1:

```sql
BEGIN;
SELECT * FROM monitor_test WHERE id = 1; -- Простое чтение на уровне Read Committed
--Сеанс 2
SELECT pid, query FROM pg_stat_activity WHERE datname = 'lab06';
SELECT locktype, relation::regclass, mode,
FROM pg_locks
WHERE pid = 27904;
```

```
BEGIN
 id 
----
  1
(1 row)

  pid  |                              query                               
-------+------------------------------------------------------------------
 27904 | SELECT * FROM monitor_test WHERE id = 1;
 28110 | SELECT pid, query FROM pg_stat_activity WHERE datname = 'lab06';
(2 rows)

  locktype  |   relation   |      mode       
------------+--------------+-----------------
 relation   | monitor_test | AccessShareLock
 virtualxid |              | ExclusiveLock  
(2 rows)
```

Получена блокировка типа `relation` в режиме `AccessShareLock`. Этот тип легкой блокировки захватывается при любом запросе на чтение (`SELECT`) и предотвращает конфликтующие операции, такие как `DROP TABLE` или `ALTER TABLE`, во время выполнения вашего запроса. Блокировок строк при простом `SELECT` на `READ COMMITTED` обычно не возникает.

#### Задача 2:
```sql
CREATE TABLE pred_demo(id INT PRIMARY KEY, v INT);
INSERT INTO pred_demo SELECT g, g FROM generate_series(1,500) g;
CREATE INDEX ON pred_demo(v);
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT count(*) FROM pred_demo WHERE v BETWEEN 100 AND 400;
INSERT INTO pred_demo VALUES (2000, 200);
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT count(*) FROM pred_demo WHERE v BETWEEN 100 AND 400;
INSERT INTO pred_demo VALUES (2001, 200);
COMMIT;
COMMIT;
```
```
CREATE TABLE
INSERT 0 500
CREATE INDEX
BEGIN
SET

 count 
-------
   205
(1 row)

INSERT 0 1
BEGIN
SET

 count 
-------
   205
(1 row)
INSERT 0 1
COMMIT

ERROR:  could not serialize access due to read/write dependencies among transactions
DETAIL:  Reason code: Canceled on identification as a pivot, during commit attempt.
HINT:  The transaction might succeed if retried.
```
#### Задача 3:
```sql
ALTER SYSTEM SET log_lock_waits = on;
ALTER SYSTEM SET deadlock_timeout = '500ms';
SELECT pg_reload_conf();
BEGIN;
UPDATE monitor_test SET v = v+1 WHERE id=1;
BEGIN;
UPDATE monitor_test SET v = v+1 WHERE id=1;
ROLLBACK;
```
```bash
sudo tail -n 200 /var/log/postgresql/postgresql-16-main.log
```

```
ALTER SYSTEM
ALTER SYSTEM
 pg_reload_conf 
----------------
 t
(1 row)
BEGIN
UPDATE 1
BEGIN
ROLLBACK
2025-11-15 14:05:59.839 MSK [141471] ilyas@lab06_db LOG:  process 141471 acquired ShareLock on transaction 366374 after 310068.379 ms
2025-11-15 14:05:59.839 MSK [141471] ilyas@lab06_db CONTEXT:  while updating tuple (0,1) in relation "lock_obj"
2025-11-15 14:05:59.839 MSK [141471] ilyas@lab06_db STATEMENT:  UPDATE lock_obj SET v = v+1 WHERE id=1;
```
### Модуль 3: Блокировки строк
#### Задача 1:
```sql
BEGIN;
UPDATE monitor_test SET id = id + 200 WHERE id = 1;
BEGIN;
UPDATE monitor_test SET id = id + 300 WHERE id = 1; -- Будет ждать
SELECT pid, query, state FROM pg_stat_activity WHERE datname = 'lab06' AND query LIKE 'UPDATE%';
-- Посмотрите блокировки для всех процессов
SELECT l.pid, l.locktype, l.relation::regclass, l.mode, l.granted, a.query
FROM pg_locks l
JOIN pg_stat_activity a ON l.pid = a.pid
WHERE a.datname = 'lab06' AND a.query LIKE 'UPDATE%';
```

```
 pid  |                        query                        |        state        
-------+-----------------------------------------------------+---------------------
 30034 | UPDATE monitor_test SET id = id + 200 WHERE id = 1; | idle in transaction
 33649 | UPDATE monitor_test SET id = id + 300 WHERE id = 1; | idle in transaction
(2 rows)
  pid  |  locktype  |   relation   |       mode       | granted |                        query                        
-------+------------+--------------+------------------+---------+-----------------------------------------------------
 33649 | relation   | monitor_test | RowExclusiveLock | t       | UPDATE monitor_test SET id = id + 300 WHERE id = 1;
 33649 | virtualxid |              | ExclusiveLock    | t       | UPDATE monitor_test SET id = id + 300 WHERE id = 1;
 30034 | relation   | monitor_test | RowExclusiveLock | t       | UPDATE monitor_test SET id = id + 200 WHERE id = 1;
 30034 | virtualxid |              | ExclusiveLock    | t       | UPDATE monitor_test SET id = id + 200 WHERE id = 1;
(4 rows)
```
#### Задача 2:
```sql
BEGIN;
UPDATE monitor_test SET id = 10 WHERE id = 1;
BEGIN;
UPDATE monitor_test SET id = 20 WHERE id = 2;
BEGIN;
UPDATE monitor_test SET id = 30 WHERE id = 3;
UPDATE monitor_test SET id = 40 WHERE id = 2; -- Ждет Сессию 2
UPDATE monitor_test SET id = 50 WHERE id = 3; -- Ждет Сессию 3
UPDATE monitor_test SET id = 60 WHERE id = 1; -- Ждет Сессию 1 -> ЦИКЛ! DEADLOCK!
```

```
2025-11-15 14:50:31.184 MSK [33649] ilyas@lab06 LOG:  process 33649 continues to wait for ShareLock on transaction 151156 for 1070.499 ms
2025-11-15 14:50:31.184 MSK [33649] ilyas@lab06 DETAIL:  Process holding the lock: 30034. Wait queue: 33649.
2025-11-15 14:50:31.184 MSK [33649] ilyas@lab06 CONTEXT:  while updating tuple (0,2) in relation "monitor_test"
2025-11-15 14:50:31.184 MSK [33649] ilyas@lab06 STATEMENT:  UPDATE monitor_test SET id = 44 WHERE id = 2;
2025-11-15 14:50:35.777 MSK [30034] ilyas@lab06 LOG:  process 30034 continues to wait for ShareLock on transaction 151157 for 1068.284 ms
2025-11-15 14:50:35.777 MSK [30034] ilyas@lab06 DETAIL:  Process holding the lock: 30026. Wait queue: 30034.
2025-11-15 14:50:35.777 MSK [30034] ilyas@lab06 CONTEXT:  while updating tuple (0,3) in relation "monitor_test"
2025-11-15 14:50:35.777 MSK [30034] ilyas@lab06 STATEMENT:  UPDATE monitor_test SET id = 55 WHERE id = 3;
```

#### Задача 3:
```sql
CREATE TABLE deadlock_test (id SERIAL PRIMARY KEY, value INT);
INSERT INTO deadlock_test (value) VALUES (1), (2);
BEGIN;
UPDATE deadlock_test SET v = v+1 WHERE id = 1;
BEGIN;
UPDATE deadlock_test SET v = v+1 WHERE id = 2;
UPDATE deadlock_test SET v = v+1 WHERE id = 2;
UPDATE deadlock_test SET v = v+1 WHERE id = 1;
```
```
BEGIN
UPDATE 1

BEGIN
```
Невозможно создать взаимоблокировку, если две транзакции выполняют по одному `UPDATE` на одной и той же таблице, если они изменяют одни и те же строки. Первый `UPDATE` захватит блокировки, второй будет ждать.

### Модуль 4: Блокировки в оперативной памяти
#### Задача 1:
```sql
BEGIN;
DECLARE test_cursor CURSOR FOR SELECT * FROM monitor_test;
FETCH NEXT FROM test_cursor;
SELECT c.relname, COUNT(*) AS buffers
FROM pg_buffercache b
JOIN pg_class c ON b.relfilenode = pg_relation_filenode(c.oid)
WHERE c.relname = 'monitor_test'
GROUP BY c.relname;
```
```
BEGIN
DECLARE CURSOR
 id 
----
  2
(1 row)

   relname    | buffers 
--------------+---------
 monitor_test |       1
(1 row)
```
#### Задача 2:
```sql
VACUUM monitor_test;
```
Обычный `VACUUM` не требует эксклюзивных блокировок и может работать параллельно с чтением данных.

#### Задача 3:
```sql
BEGIN;
DECLARE test_cursor CURSOR FOR SELECT * FROM monitor_test;
FETCH NEXT FROM test_cursor;
VACUUM FREEZE monitor_test;
-- Сеанс 3
-- Мониторинг ожиданий
SELECT pid, wait_event_type, wait_event, query
FROM pg_stat_activity
WHERE datname = 'lab06' AND query LIKE 'VACUUM%';
```
```
BEGIN
DECLARE CURSOR
 id 
----
  2
(1 row)

-- Сеанс 3
  pid  | wait_event_type | wait_event |            query            
-------+-----------------+------------+-----------------------------
 30034 | BufferPin       | BufferPin  | VACUUM FREEZE monitor_test;
(1 row)
 ```

## Выводы
В ходе выполнения лабораторной работы были успешно изучены и практически освоены ключевые аспекты системы блокировок PostgreSQL и методов мониторинга активности сервера.