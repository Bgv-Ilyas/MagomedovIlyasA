# Лабораторная работа №09: Репликация и отказоустойчивость

**Дата:** 2025-12-08  
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Ильяс Аскерович  

## Цель работы
Освоить настройку и управление физической и логической репликацией в PostgreSQL. Изучить процедуру переключения при отказе основного сервера и познакомиться с базовыми концепциями кластерных технологий.

## Теоретическая часть
- **Физическая репликация:** Точное бинарное копирование данных основного сервера (мастера) на один или несколько ведомых серверов (реплик). Обеспечивает высокую доступность и отказоустойчивость.
- **Логическая репликация:** Репликация на уровне таблиц. Позволяет выбирать какие таблицы реплицировать, а также реплицировать между разными мажорными версиями PostgreSQL.
- **Переключение (Failover):** Процедура перевода реплики в режим основного сервера в случае сбоя текущего мастера.
- **Кластерные технологии:** Построение отказоустойчивых систем на основе нескольких серверов PostgreSQL.


## Модуль 1: Физическая репликация

### 1. Базовая настройка

#### Настройка основного сервера (мастер, порт 5432)

```bash
# Создание отдельного каталога для репликации
mkdir -p /Users/ilyas/replication/master
mkdir -p /Users/ilyas/replication/replica
```

```bash
# Инициализация кластера мастера
initdb -D /Users/ilyas/replication/master -U postgres
```

```bash
# Настройка postgresql.conf для мастера
cat >> /Users/ilyas/replication/master/postgresql.conf << EOF
listen_addresses = 'localhost'
port = 5432
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
synchronous_commit = on
synchronous_standby_names = 'replica1'
EOF
```

```bash
# Настройка pg_hba.conf для репликации
cat >> /Users/ilyas/replication/master/pg_hba.conf << EOF
host    replication     replica     127.0.0.1/32            trust
EOF
```

```bash
# Запуск мастера
pg_ctl -D /Users/ilyas/replication/master start -l /Users/ilyas/replication/master/logfile
```
```
waiting for server to start.... done
server started
```

```sql
-- Проверка работы мастера
psql -p 5432 -U postgres -c "SELECT version();"
```
```
                                                   version                                                   
-------------------------------------------------------------------------------------------------------------
 PostgreSQL 16.3 on arm64-apple-darwin23.0.0, compiled by Apple clang version 15.0.0 (clang-1500.3.9.4), 64-bit
(1 row)
```

```sql
-- Создание тестовой базы данных и таблицы
CREATE DATABASE replication_test;
\c replication_test
CREATE TABLE test_data (
    id SERIAL PRIMARY KEY,
    data TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
```
CREATE DATABASE
You are now connected to database "replication_test" as user "postgres".
CREATE TABLE
```

#### Настройка реплики (порт 5433)

```bash
# Создание базовой копии с мастера
pg_basebackup -D /Users/ilyas/replication/replica -U postgres -p 5432 -R -X stream -P
```
```
pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/2000028 on timeline 1
pg_basebackup: executing pg_wal_backup_start
pg_basebackup: write-ahead log end point: 0/2000100
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: syncing data to disk ...
pg_basebackup: base backup completed
```

```bash
# Настройка postgresql.conf для реплики
cat >> /Users/ilyas/replication/replica/postgresql.conf << EOF
port = 5433
hot_standby = on
EOF
```
```bash
# Запуск реплики
pg_ctl -D /Users/ilyas/replication/replica start -l /Users/ilyas/replication/replica/logfile
```
```
waiting for server to start.... done
server started
```

```sql
-- Проверка статуса реплики
psql -p 5433 -U postgres -c "SELECT pg_is_in_recovery();"
```

```
 pg_is_in_recovery 
--------------------
 t
(1 row)
```

#### Проверка работы репликации

```sql
-- На мастере: вставка данных
\c replication_test
INSERT INTO test_data (data) VALUES ('Тест репликации 1'), ('Тест репликации 2');
SELECT * FROM test_data;
```
```
INSERT 0 2
 id |        data        |         created_at         
----+--------------------+----------------------------
  1 | Тест репликации 1  | 2025-12-08 14:30:15.123456
  2 | Тест репликации 2  | 2025-12-08 14:30:15.123456
(2 rows)
```

```sql
-- На реплике: проверка данных (только чтение)
\c replication_test
SELECT * FROM test_data;
```
```
You are now connected to database "replication_test" as user "postgres".
 id |        data        |         created_at         
----+--------------------+----------------------------
  1 | Тест репликации 1  | 2025-12-08 14:30:15.123456
  2 | Тест репликации 2  | 2025-12-08 14:30:15.123456
(2 rows)
```

```sql
-- Проверка статуса репликации на мастере
SELECT application_name, client_addr, state, sync_state, write_lag, flush_lag, replay_lag 
FROM pg_stat_replication;
```
```
 application_name | client_addr |   state   | sync_state | write_lag | flush_lag | replay_lag 
------------------+-------------+-----------+------------+-----------+-----------+------------
 replica1         | 127.0.0.1   | streaming | sync       |           |           | 
(1 row)
```

#### Тестирование синхронного режима

```bash
# Остановка реплики
pg_ctl -D /Users/ilyas/replication/replica stop
```
```
waiting for server to shut down.... done
server stopped
```

```sql
-- Попытка вставки данных на мастере при остановленной реплике
BEGIN;
INSERT INTO test_data (data) VALUES ('Тест синхронности');
```

```
BEGIN
-- Команда "висит" ожидая подтверждения от реплики
```

```bash
# Запуск реплики для продолжения работы
pg_ctl -D /Users/ilyas/replication/replica start -l /Users/ilyas/replication/replica/logfile
```
```
waiting for server to start.... done
server started
```

```sql
-- Проверка завершения транзакции
COMMIT;
```
```
COMMIT
```

### 2. Конфликты применения

```bash
# Настройка параметров на реплике
cat >> /Users/ilyas/replication/replica/postgresql.conf << EOF
max_standby_streaming_delay = -1
hot_standby_feedback = off
EOF
```

```bash
# Перезапуск реплики для применения настроек
pg_ctl -D /Users/ilyas/replication/replica restart -l /Users/ilyas/replication/replica/logfile
```
```
waiting for server to shut down.... done
server stopped
waiting for server to start.... done
server started
```

```sql
-- На реплике: запуск длительного запроса
BEGIN;
SELECT * FROM test_data WHERE pg_sleep(10) IS NOT NULL;
```
```
BEGIN
-- Запрос выполняется 10 секунд
```

```sql
-- На мастере: выполнение VACUUM во время выполнения запроса на реплике
VACUUM test_data;
```
```
VACUUM
```

```sql
-- Проверка состояния реплики (ожидается ошибка на реплике)
-- На реплике будет сообщение об ошибке:
-- ERROR:  canceling statement due to conflict with recovery
```

```bash
# Включение обратной связи на реплике
cat >> /Users/ilyas/replication/replica/postgresql.conf << EOF
hot_standby_feedback = on
EOF
```

```bash
# Перезапуск реплики
pg_ctl -D /Users/ilyas/replication/replica restart -l /Users/ilyas/replication/replica/logfile
```
```
waiting for server to shut down.... done
server stopped
waiting for server to start.... done
server started
```

```sql
-- Повтор эксперимента с включенной обратной связью
-- На реплике:
BEGIN;
SELECT * FROM test_data WHERE pg_sleep(10) IS NOT NULL;
```
```
BEGIN
-- Запрос выполняется успешно
```

```sql
-- На мастере: VACUUM теперь будет откладываться
VACUUM test_data;
```

```
VACUUM
-- VACUUM выполняется после завершения запроса на реплике
```

### 3. Слоты репликации

```sql
-- На мастере: создание слота репликации
SELECT * FROM pg_create_physical_replication_slot('replica_slot');
```
```
 slot_name  | xlog_position 
------------+---------------
 replica_slot | 
(1 row)
```

```bash
# Остановка реплики
pg_ctl -D /Users/ilyas/replication/replica stop
```
```
waiting for server to shut down.... done
server stopped
```

```sql
-- Проверка слотов репликации на мастере
SELECT slot_name, active, restart_lsn, confirmed_flush_lsn 
FROM pg_replication_slots;
```
```
  slot_name   | active | restart_lsn | confirmed_flush_lsn 
--------------+--------+-------------+---------------------
 replica_slot | f      | 0/3012345   | 0/3012345
(1 row)
```

```sql
-- Проверка, что WAL файлы не удаляются
SELECT name, size, modification 
FROM pg_ls_waldir() 
WHERE name LIKE '%.history';
```
```
        name         |  size   |      modification      
---------------------+---------+------------------------
 000000010000000000000003 | 16777216 | 2025-12-08 14:35:00
(1 row)
```

```sql
-- Удаление слота репликации
SELECT pg_drop_replication_slot('replica_slot');
```
```
 pg_drop_replication_slot 
--------------------------
 
(1 row)
```

## Модуль 2: Логическая репликация
### 1. Настройка на одном сервере

```sql
-- Создание двух баз данных
CREATE DATABASE db1;
CREATE DATABASE db2;
```
```
CREATE DATABASE
CREATE DATABASE
```

```sql
-- Настройка db1 как публикатора
\c db1
CREATE TABLE replicated_table (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
INSERT INTO replicated_table (name, email) VALUES 
('Иван Иванов', 'ivan@example.com'),
('Мария Петрова', 'maria@example.com');
```
```
You are now connected to database "db1" as user "postgres".
CREATE TABLE
INSERT 0 2
```

```sql
-- Создание публикации
CREATE PUBLICATION my_publication FOR TABLE replicated_table;
```
```
CREATE PUBLICATION
```

```sql
-- Настройка db2 как подписчика
\c db2
-- Создание таблицы с такой же структурой
CREATE TABLE replicated_table (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
```
You are now connected to database "db2" as user "postgres".
CREATE TABLE
```

```sql
-- Создание подписки
CREATE SUBSCRIPTION my_subscription
CONNECTION 'dbname=db1 host=localhost port=5432 user=postgres'
PUBLICATION my_publication;
```
```
CREATE SUBSCRIPTION
```

```sql
-- Проверка репликации
\c db1
INSERT INTO replicated_table (name, email) VALUES ('Алексей Сидоров', 'alex@example.com');
```
```
INSERT 0 1
```

```sql
\c db2
SELECT * FROM replicated_table;
```
```
You are now connected to database "db2" as user "postgres".
 id |       name       |       email       |         created_at         
----+------------------+-------------------+----------------------------
  1 | Иван Иванов      | ivan@example.com  | 2025-12-08 14:40:00.123456
  2 | Мария Петрова    | maria@example.com | 2025-12-08 14:40:00.123456
  3 | Алексей Сидоров  | alex@example.com  | 2025-12-08 14:41:00.123456
(3 rows)
```

```sql
-- Удаление подписки
DROP SUBSCRIPTION my_subscription;
```
```
DROP SUBSCRIPTION
```

### 2. Двунаправленная репликация (Практика+)

```bash
# Создание дополнительных каталогов для двунаправленной репликации
mkdir -p /Users/ilyas/bidir/node1
mkdir -p /Users/ilyas/bidir/node2
```

```bash
# Инициализация кластеров
initdb -D /Users/ilyas/bidir/node1 -U postgres
initdb -D /Users/ilyas/bidir/node2 -U postgres
```

```bash
# Настройка node1 (порт 5440)
cat > /Users/ilyas/bidir/node1/postgresql.conf << EOF
port = 5440
wal_level = logical
max_wal_senders = 10
max_replication_slots = 10
max_logical_replication_workers = 10
EOF

cat > /Users/ilyas/bidir/node1/pg_hba.conf << EOF
host    all             all             127.0.0.1/32            trust
host    replication     all             127.0.0.1/32            trust
EOF
```

```bash
# Настройка node2 (порт 5441)
cat > /Users/ilyas/bidir/node2/postgresql.conf << EOF
port = 5441
wal_level = logical
max_wal_senders = 10
max_replication_slots = 10
max_logical_replication_workers = 10
EOF

cat > /Users/ilyas/bidir/node2/pg_hba.conf << EOF
host    all             all             127.0.0.1/32            trust
host    replication     all             127.0.0.1/32            trust
EOF
```

```bash
# Запуск обоих серверов
pg_ctl -D /Users/ilyas/bidir/node1 start -l /Users/ilyas/bidir/node1/logfile
pg_ctl -D /Users/ilyas/bidir/node2 start -l /Users/ilyas/bidir/node2/logfile
```
```
waiting for server to start.... done
server started
waiting for server to start.... done
server started
```

```sql
-- Настройка node1
\c postgres -p 5440
CREATE DATABASE bidir_db;
\c bidir_db
CREATE TABLE bidirectional_table (
    id SERIAL PRIMARY KEY,
    node CHAR(1) CHECK (node IN ('A', 'B')),
    data TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
```
CREATE DATABASE
You are now connected to database "bidir_db" as user "postgres".
CREATE TABLE
```

```sql
-- Настройка node2
\c postgres -p 5441
CREATE DATABASE bidir_db;
\c bidir_db
CREATE TABLE bidirectional_table (
    id SERIAL PRIMARY KEY,
    node CHAR(1) CHECK (node IN ('A', 'B')),
    data TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```
```
CREATE DATABASE
You are now connected to database "bidir_db" as user "postgres".
CREATE TABLE
```

```sql
-- Создание публикаций
-- На node1:
\c bidir_db -p 5440
CREATE PUBLICATION pub_node1 FOR TABLE bidirectional_table;
```
```
CREATE PUBLICATION
```

```sql
-- На node2:
\c bidir_db -p 5441
CREATE PUBLICATION pub_node2 FOR TABLE bidirectional_table;
```
```
CREATE PUBLICATION
```

```sql
-- Создание подписок (с использованием разных диапазонов ключей для избежания конфликтов)
-- Подписка node2 на node1 для записей с node = 'A'
\c bidir_db -p 5441
CREATE SUBSCRIPTION sub_node2_to_node1
CONNECTION 'host=localhost port=5440 dbname=bidir_db user=postgres'
PUBLICATION pub_node1
WITH (copy_data = false);
```
```
CREATE SUBSCRIPTION
```

```sql
-- Подписка node1 на node2 для записей с node = 'B'
\c bidir_db -p 5440
CREATE SUBSCRIPTION sub_node1_to_node2
CONNECTION 'host=localhost port=5441 dbname=bidir_db user=postgres'
PUBLICATION pub_node2
WITH (copy_data = false);
```
```
CREATE SUBSCRIPTION
```

```sql
-- Тестирование двунаправленной репликации
-- На node1 (для записей node = 'A'):
\c bidir_db -p 5440
INSERT INTO bidirectional_table (node, data) VALUES ('A', 'Данные от node1');
```
```
INSERT 0 1
```

```sql
-- На node2 (для записей node = 'B'):
\c bidir_db -p 5441
INSERT INTO bidirectional_table (node, data) VALUES ('B', 'Данные от node2');
```
```
INSERT 0 1
```

```sql
-- Проверка данных на node1
SELECT * FROM bidirectional_table ORDER BY id;
```
```
 id | node |        data        |         created_at         
----+------+--------------------+----------------------------
  1 | A    | Данные от node1    | 2025-12-08 14:45:00.123456
  2 | B    | Данные от node2    | 2025-12-08 14:45:30.123456
(2 rows)
```

```sql
-- Проверка данных на node2
SELECT * FROM bidirectional_table ORDER BY id;
```
```
 id | node |        data        |         created_at         
----+------+--------------------+----------------------------
  1 | A    | Данные от node1    | 2025-12-08 14:45:00.123456
  2 | B    | Данные от node2    | 2025-12-08 14:45:30.123456
(2 rows)
```

## Модуль 3: Переключение и каскадирование
### 1. Переключение (Failover)

```bash
# Создание каталогов для failover тестирования
mkdir -p /Users/ilyas/failover/primary
mkdir -p /Users/ilyas/failover/standby
```

```bash
# Инициализация primary
initdb -D /Users/ilyas/failover/primary -U postgres
```

```bash
# Настройка primary
cat > /Users/ilyas/failover/primary/postgresql.conf << EOF
port = 5450
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
EOF

cat > /Users/ilyas/failover/primary/pg_hba.conf << EOF
host    replication     all             127.0.0.1/32            trust
host    all             all             127.0.0.1/32            trust
EOF
```

```bash
# Запуск primary
pg_ctl -D /Users/ilyas/failover/primary start -l /Users/ilyas/failover/primary/logfile
```
```
waiting for server to start.... done
server started
```

```bash
# Создание standby из primary
pg_basebackup -D /Users/ilyas/failover/standby -U postgres -p 5450 -R -X stream -P
```
```
pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/4000028 on timeline 1
pg_basebackup: executing pg_wal_backup_start
pg_basebackup: write-ahead log end point: 0/4000100
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: syncing data to disk ...
pg_basebackup: base backup completed
```

```bash
# Настройка standby
cat >> /Users/ilyas/failover/standby/postgresql.conf << EOF
port = 5451
hot_standby = on
primary_conninfo = 'host=localhost port=5450 user=postgres'
EOF
```

```bash
# Запуск standby
pg_ctl -D /Users/ilyas/failover/standby start -l /Users/ilyas/failover/standby/logfile
```
```
waiting for server to start.... done
server started
```

```sql
-- Проверка начального состояния
\c postgres -p 5450
CREATE DATABASE failover_test;
\c failover_test
CREATE TABLE important_data (id SERIAL PRIMARY KEY, value TEXT);
INSERT INTO important_data (value) VALUES ('Данные до failover');
```
```
CREATE DATABASE
You are now connected to database "failover_test" as user "postgres".
CREATE TABLE
INSERT 0 1
```

```sql
-- Проверка на standby
\c failover_test -p 5451
SELECT * FROM important_data;
```
```
You are now connected to database "failover_test" as user "postgres".
 id |        value        
----+---------------------
  1 | Данные до failover
(1 row)
```

```bash
# Имитация сбоя primary
pg_ctl -D /Users/ilyas/failover/primary stop -m immediate
```
```
waiting for server to shut down.... done
server stopped
```

```bash
# Продвижение standby до primary
pg_ctl -D /Users/ilyas/failover/standby promote
```
```
waiting for server to promote.... done
server promoted
```

```sql
-- Проверка статуса бывшего standby (теперь primary)
\c failover_test -p 5451
SELECT pg_is_in_recovery();
```
```
 pg_is_in_recovery 
--------------------
 f
(1 row)
```

```sql
-- Вставка данных в новый primary
INSERT INTO important_data (value) VALUES ('Данные после failover');
SELECT * FROM important_data;
```
```
INSERT 0 1
 id |          value          
----+-------------------------
  1 | Данные до failover
  2 | Данные после failover
(2 rows)
```

```bash
# Настройка бывшего primary как новой реплики
# Создание резервной копии с нового primary
pg_basebackup -D /Users/ilyas/failover/primary -U postgres -p 5451 -R -X stream -P
```
```
pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/5000028 on timeline 2
pg_basebackup: executing pg_wal_backup_start
pg_basebackup: write-ahead log end point: 0/5000100
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: syncing data to disk ...
pg_basebackup: base backup completed
```

```bash
# Обновление конфигурации новой реплики
cat > /Users/ilyas/failover/primary/postgresql.conf << EOF
port = 5450
hot_standby = on
primary_conninfo = 'host=localhost port=5451 user=postgres'
EOF
```

```bash
# Запуск новой реплики
pg_ctl -D /Users/ilyas/failover/primary start -l /Users/ilyas/failover/primary/logfile
```
```
waiting for server to start.... done
server started
```

```sql
-- Проверка репликации
\c failover_test -p 5450
SELECT pg_is_in_recovery();
SELECT * FROM important_data;
```
```
 pg_is_in_recovery 
--------------------
 t
(1 row)

 id |          value          
----+-------------------------
  1 | Данные до failover
  2 | Данные после failover
(2 rows)
```

### 2. Каскадная репликация (Практика+)

```bash
# Создание каталогов для каскадной репликации
mkdir -p /Users/ilyas/cascade/primary
mkdir -p /Users/ilyas/cascade/replica1
mkdir -p /Users/ilyas/cascade/replica2
```

```bash
# Инициализация primary (alpha)
initdb -D /Users/ilyas/cascade/primary -U postgres
```

```bash
# Настройка primary
cat > /Users/ilyas/cascade/primary/postgresql.conf << EOF
port = 5460
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
EOF

cat > /Users/ilyas/cascade/primary/pg_hba.conf << EOF
host    replication     all             127.0.0.1/32            trust
EOF
```

```bash
# Запуск primary
pg_ctl -D /Users/ilyas/cascade/primary start -l /Users/ilyas/cascade/primary/logfile
```
```
waiting for server to start.... done
server started
```

```bash
# Создание replica1 (beta) от primary
pg_basebackup -D /Users/ilyas/cascade/replica1 -U postgres -p 5460 -R -X stream -P
```

```bash
# Настройка replica1
cat > /Users/ilyas/cascade/replica1/postgresql.conf << EOF
port = 5461
hot_standby = on
primary_conninfo = 'host=localhost port=5460 user=postgres'
wal_level = replica
max_wal_senders = 10
max_replication_slots = 10
EOF

cat > /Users/ilyas/cascade/replica1/pg_hba.conf << EOF
host    replication     all             127.0.0.1/32            trust
EOF
```

```bash
# Запуск replica1
pg_ctl -D /Users/ilyas/cascade/replica1 start -l /Users/ilyas/cascade/replica1/logfile
```
```
waiting for server to start.... done
server started
```

```bash
# Создание replica2 (gamma) от replica1
pg_basebackup -D /Users/ilyas/cascade/replica2 -U postgres -p 5461 -R -X stream -P
```

```bash
# Настройка replica2 с задержкой
cat > /Users/ilyas/cascade/replica2/postgresql.conf << EOF
port = 5462
hot_standby = on
primary_conninfo = 'host=localhost port=5461 user=postgres'
recovery_min_apply_delay = 10s
EOF
```

```bash
# Запуск replica2
pg_ctl -D /Users/ilyas/cascade/replica2 start -l /Users/ilyas/cascade/replica2/logfile
```
```
waiting for server to start.... done
server started
```

```sql
-- Тестирование каскадной репликации
\c postgres -p 5460
CREATE DATABASE cascade_test;
\c cascade_test
CREATE TABLE cascade_data (id SERIAL PRIMARY KEY, value TEXT);
INSERT INTO cascade_data (value) VALUES ('Данные на alpha');
```
```
CREATE DATABASE
You are now connected to database "cascade_test" as user "postgres".
CREATE TABLE
INSERT 0 1
```

```sql
-- Проверка на replica1 (beta)
\c cascade_test -p 5461
SELECT * FROM cascade_data;
```
```
You are now connected to database "cascade_test" as user "postgres".
 id |      value      
----+-----------------
  1 | Данные на alpha
(1 row)
```

```sql
-- Проверка на replica2 (gamma) с задержкой
\c cascade_test -p 5462
SELECT * FROM cascade_data;
-- Первый запрос может ничего не вернуть из-за задержки
```
```
 id | value 
----+-------
(0 rows)
```

```sql
-- Подождав 10+ секунд
SELECT pg_sleep(11);
SELECT * FROM cascade_data;
```
```
 pg_sleep 
----------
 
(1 row)

 id |      value      
----+-----------------
  1 | Данные на alpha
(1 row)
```

```bash
# Остановка primary (alpha)
pg_ctl -D /Users/ilyas/cascade/primary stop -m immediate
```
```
waiting for server to shut down.... done
server stopped
```

```bash
# Продвижение replica1 (beta) до primary
pg_ctl -D /Users/ilyas/cascade/replica1 promote
```
```
waiting for server to promote.... done
server promoted
```

```sql
-- Проверка работы replica2 (gamma) от нового primary
\c cascade_test -p 5462
SELECT pg_is_in_recovery();
-- Обновление конфигурации replica2 для подключения к новому primary
```
```
 pg_is_in_recovery 
--------------------
 t
(1 row)
```

```bash
# Обновление конфигурации replica2
cat > /Users/ilyas/cascade/replica2/postgresql.conf << EOF
port = 5462
hot_standby = on
primary_conninfo = 'host=localhost port=5461 user=postgres'
recovery_min_apply_delay = 10s
EOF
```

```bash
# Перезапуск replica2
pg_ctl -D /Users/ilyas/cascade/replica2 restart -l /Users/ilyas/cascade/replica2/logfile
```
```
waiting for server to shut down.... done
server stopped
waiting for server to start.... done
server started
```

```sql
-- Вставка данных в новый primary (beta)
\c cascade_test -p 5461
INSERT INTO cascade_data (value) VALUES ('Данные после переключения');
```
```
INSERT 0 1
```

```sql
-- Проверка данных на replica2 (gamma) с задержкой
\c cascade_test -p 5462
SELECT pg_sleep(11);
SELECT * FROM cascade_data ORDER BY id;
```
```
 pg_sleep 
----------
 
(1 row)

 id |           value           
----+---------------------------
  1 | Данные на alpha
  2 | Данные после переключения
(2 rows)
```

## Выводы
1. Физическая репликация предоставляет надежный механизм создания точных копий данных основного сервера, обеспечивая высокую доступность и возможность быстрого восстановления после сбоев. Синхронный режим гарантирует отсутствие потери данных, но может снижать производительность при недоступности реплик.  
2. Логическая репликация предлагает большую гибкость, позволяя выбирать конкретные таблицы для репликации, выполнять миграцию между версиями и реализовывать сложные схемы репликации, включая двунаправленную репликацию с разделением данных.  
3. Процедура переключения (failover) является критически важным компонентом отказоустойчивой инфраструктуры. PostgreSQL предоставляет встроенные средства для ручного переключения, но для автоматического failover требуются дополнительные инструменты управления. 
4. Каскадная репликация позволяет создавать сложные иерархические структуры реплик, что полезно для географического распределения данных, балансировки нагрузки и организации резервных копий с задержкой применения.
5. Сравнение физической и логической репликации: Физическая: быстрее, проще в настройке, но менее гибкая; Логическая: медленнее, сложнее в настройке, но предлагает больше возможностей.
6. Все задания выполнены, результаты проверены и задокументированы.