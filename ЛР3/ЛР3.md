### Модель многопользовательского доступа: MVCC

**Дата:** 2025-10-22  
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Ильяс Аскерович

### Цель работы
Изучить принципы многоверсионного управления конкурентным доступом (MVCC) в PostgreSQL. Получить практические навыки наблюдения за работой MVCC, анализа версий строк, снимков данных и уровней изоляции транзакций. Освоить использование расширений и системных представлений для исследования внутренней структуры данных.

### Теоретическая часть
**MVCC (Multiversion Concurrency Control)** — механизм, позволяющий нескольким транзакциям работать с одними и теми же данными одновременно, минимизируя блокировки. Каждая транзакция видит согласованный «снимок» данных на момент своего
начала. 
1. Версии строк: При изменении строки создается ее новая версия. Старая версия остается в таблице до очистки.
2. Системные поля:
- xmin – идентификатор транзакции, создавшей версию строки.
- xmax — идентификатор транзакции, удалившей версию строки (или заблокировавшей ее для обновления).
- ctid — физическое расположение версии строки в таблице (номер страницы и позиции в ней).
3. Уровни изоляции: Определяют, какие аномалии параллелизма допустимы:
- Read Committed (По умолчанию): Виден только зафиксированный данные. Возможны неповторяемое чтение и фантомное чтение.
- Repeatable Read: Гарантирует, что данные, прочитанные в транзакции, не изменятся. Предотвращает неповторяемое чтение, возможны фантомы.
- Serializable: Самый строгий уровень, предотвращает все аномалии.
4. Снимок данных (Snapshot): Набор идентификаторов транзакций, активных на момент начала текущей транзакции. Определяет, какие версии строк видимы текущей транзакции.


### Модуль 1:  Уровни изоляции и аномалии

#### Задача 1: Read Committed vs Удаление

Read Committed (Чтение зафиксированных данных) **- Уровень по умолчанию в PostgreSQL**

**Как работает:** Каждый оператор `SELECT` в транзакции видит только те данные, которые были зафиксированы **на момент начала выполнения этого оператора `SELECT`**.

**Сеанс 1:**
```sql
-- Сеанс 1
CREATE DATABASE lab03_db;
\c lab03_db
CREATE TABLE iso_test(id INT, data TEXT);
INSERT INTO iso_test VALUES (1,'row1');

BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM iso_test;
```

```
CREATE TABLE

INSERT 0 1

BEGIN

 id | data 
----+------
  1 | row1
(1 row)
```

**Что происходит:** cоздалась таблица, добавили данные и начали транзакцию. Пока видим одну строку.

**Сеанс 2:**
``` sql
DELETE FROM iso_test;

COMMIT;
```

```
DELETE 1

COMMIT
```
**Что происходит:** удаление всех данные из таблицы и подтверждение изменений.

**Сеанс 1:**
``` sql
SELECT * FROM iso_test;

COMMIT;
```

```
+----+------+
| id | data |
|----+------|
+----+------+
SELECT 0

COMMIT
```
**Объяснение результата:** на уровне `READ COMMITTED` мы увидим, что строки исчезли, потому что эта транзакция видит изменения, подтвержденные другими.

#### Задача 2: Repeatable Read vs Удаление

Repeatable Read (Повторяемое чтение)

**Как работает:** транзакция видит только те данные, которые были зафиксированы **на момент начала самой транзакции** (при выполнении первого оператора). Весь последующий `SELECT` внутри транзакции будет видеть один и тот же "снимок" данных.

**Сеанс 1**:
``` sql
INSERT INTO iso_test VALUES (1,'row1');
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM iso_test;
```

```
INSERT 0 1

BEGIN

 id | data 
----+------
  1 | row1
(1 row)
SELECT 1
```


**Сеанс 2**:
``` sql
DELETE FROM iso_test;

COMMIT;
```

```
DELETE 1

COMMIT
```

**Сеанс 1:**
``` sql
SELECT * FROM iso_test; -- Все еще видим строку

COMMIT;
```

```
 id | data 
----+------
  1 | row1
(1 row)
SELECT 1

COMMIT
```
**Объяснение результата:** На уровне `REPEATABLE READ` мы продолжим видеть строку, даже если ее удалили в другом сеансе. Транзакция работает с "снимком" данных на момент своего начала.

#### Задача 3: Создание таблицы в транзакции

**Сеанс 1:**
```sql
BEGIN;

CREATE TABLE new_table (id INT);

INSERT INTO new_table VALUES (1);
```

```
BEGIN

CREATE TABLE

INSERT 0 1
```

**Что происходит:** создали таблицу внутри транзакции, но еще не подтвердили изменения.

**Сеанс 2:**
``` sql
SELECT * FROM new_table;
```

```
ERROR:  relation "new_table" does not exist
LINE 1: SELECT * FROM new_table;
```

**Результат:** Получим ОШИБКУ - таблица не найдена!
**Объяснение:** В PostgreSQL DDL (Data Definition Language) команды (создание таблиц) являются **транзакционными**. Это значит:
- Пока транзакция не подтверждена (`COMMIT`), изменения НЕ видны другим сеансам
- Если сделать `ROLLBACK` - таблица вообще не создастся


**Сеанс 1:**
``` sql
COMMIT; -- Подтверждаем транзакцию
```

**Сеанс 2:**
``` sql
SELECT * FROM new_table;  -- Теперь таблица видна!
```

```
 id 
----
 1
(1 row)
```


**Сеанс 1:**
``` sql
BEGIN;
CREATE TABLE rollback_test (id INT);
INSERT INTO rollback_test VALUES (1);
ROLLBACK;  -- Откатываем транзакцию
```

```
BEGIN

CREATE TABLE

INSERT 0 1

ROLLBACK
```

**Сеанс 2:**
``` sql
SELECT * FROM rollback_test;
```

```
ERROR:  relation "rollback_test" does not exist
LINE 1: SELECT * FROM rollback_test
```

**Вывод:** DDL команды в PostgreSQL можно безопасно выполнять в транзакциях и откатывать при необходимости.

#### Задача 4: Блокировка DDL

**Сеанс 1:**
``` sql
BEGIN;
SELECT * FROM iso_test; -- Транзакция активна
```

```
BEGIN

 id | data 
----+------
(0 rows)
```

**Сеанс 2:**
``` sql
DROP TABLE iso_test;
```

**Результат:** Команда **зависнет** и будет ждать.
**Объяснение:**
- Когда в сеансе 1 выполняется `SELECT` в транзакции, он устанавливает блокировку на таблицу
- Команда `DROP TABLE` в сеансе 2 пытается получить эксклюзивную блокировку, но не может, потому что сеанс 1 уже держит блокировку
- Сеанс 2 будет ждать, пока сеанс 1 не завершит транзакцию

### Модуль 2:  Фантомное чтение и снимки 

**Что такое "фантомное чтение"?**
Это аномалия, когда в пределах одной транзакции при повторном выполнении одного и того же запроса появляются новые строки ("фантомы"), которые были добавлены другими транзакциями.
**Простая аналогия:** Вы смотрите на список студентов в классе, отворачиваетесь, кто-то добавляет нового студента, вы снова смотрите - и видите, что пояивился еще один студент.

#### Задача 1: Фантомное чтение на уровне Read Commited

**Сеанс 1:**
``` sql
CREATE TABLE phantom_test;
BEGIN ISOLATION LEVEL READ COMMITTED;
SELECT * FROM phantom_test;  -- Первое чтение
```

```
BEGIN


| id |
|----|
SELECT 0
```

**Результат:** Пусто

**Сеанс 2**
``` sql
INSERT INTO phantom_test VALUES (1),(2),(3);
COMMIT;  -- Подтверждаем изменения
```

```
INSERT 0 3
```

**Сеанс 1:**
```sql
SELECT * FROM phantom_test;  -- Второе чтение
COMMIT;
```

```
 id 
----
  1
  2
  3
SELECT 3
```

**Что увидим:** Во втором чтении появятся строки (1, 2, 3)
**Объяснение:**
- На уровне `READ COMMITTED` каждая команда `SELECT` видит последние подтвержденные данные
- После `COMMIT` в сеансе 2, новые строки становятся видимыми для всех последующих запросов
- Это и есть **фантомное чтение** - появление "новых" строк при повторном выполнении того же запроса


#### Задача 2: Невидимость удалений на Repeatable Read

**Сеанс 1:**
``` sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM pg_database; -- При выполнении первого оператора делается снимок данных
```


**Сеанс 2:**
``` sql
DELETE FROM phantom_test;  -- Удаляем ВСЕ строки
COMMIT;  -- Подтверждаем удаление
```

```
DELETE 3
```

**Сеанс 1:**

``` sql
SELECT * FROM phantom_test;  -- Первое чтение
SELECT * FROM pg_database;
-- Снова запрашиваем phantom_test
SELECT * FROM phantom_test;  -- Второе чтение
COMMIT;
```

```
 id 
----
  1
  2
  3
(3 rows)
```

**Результат:** Строки по-прежнему видны, хотя они уже удалены.

**Объяснение:**
- На уровне `REPEATABLE READ` транзакция работает с **снимком данных** на момент своего первого обращения к таблице
- Даже если другие транзакции удалили строки, наша транзакция продолжает видеть данные в том состоянии, в котором они были при первом запросе
- Запросы к другим таблицам **не влияют** на снимок данных для `phantom_test`

#### Задача 3: Транзакционность DDL

**Сеанс 1:**
``` sql
BEGIN;
DROP TABLE ddl_test;
-- Проверяем, что таблица "исчезла" в этой транзакции
SELECT * FROM ddl_test;  -- ОШИБКА: таблица не существует

```

```
BEGIN

DROP TABLE

ERROR:  relation "ddl_test" does not exist
LINE 1: SELECT * FROM ddl_test
```

**Сеанс 2**:
``` sql
SELECT * FROM ddl_test;  -- Таблица ВСЕ ЕЩЕ СУЩЕСТВУЕТ
```

```
 id 
----
  1
  2
  3
(3 rows)
```

**Объяснение:** DDL операции не видны другим транзакциям до `COMMIT`

**Сеанс 1:**
``` sql
ROLLBACK;  -- Откатываем транзакцию
SELECT * FROM ddl_test;  -- Таблица СНОВА ДОСТУПНА
```

```
ROLLBACK

 id 
----
  1
  2
  3
(3 rows)
```

**Сеанс 2**:
``` sql
SELECT * FROM ddl_test;
```

```
 id 
----
  1
  2
  3
(3 rows)
```

**Сеанс 1:**
``` sql
BEGIN;
DROP TABLE ddl_test;
COMMIT;  -- Подтверждаем удаление
```

```
BEGIN

You're about to run a destructive command.
Do you want to proceed? [y/N]: y
Your call!
DROP TABLE

COMMIT
```

**Сеанс 2**:
``` sql
SELECT * FROM ddl_test;  -- Теперь ОШИБКА: таблица не существует
```

```
ERROR:  relation "ddl_test" does not exist
LINE 1: SELECT * FROM ddl_test
```

### Модуль 3:  Версии строк и pageinspect

#### Задача 1: Жизненный цикл строки

``` sql
CREATE EXTENSION pageinspect;
CREATE TABLE version_test(id INT);
INSERT INTO version_test VALUES (1);
UPDATE version_test SET id=2;    
UPDATE version_test SET id=3;    
DELETE FROM version_test;     
SELECT t_xmin, t_xmax, t_ctid  FROM heap_page_items(get_raw_page('version_test',0));
```

```
CREATE EXTENSION

CREATE TABLE

INSERT 0 1

UPDATE 1

UPDATE 1

DELETE 1
 t_xmin | t_xmax | t_ctid 
--------+--------+--------
    836 |    837 | (0,2)
    837 |    838 | (0,3)
    838 |    839 | (0,3)
(3 rows)
```

**Расшифровка полей:**
- `t_xmin` - ID транзакции, которая вставила строку
- `t_xmax` - ID транзакции, которая удалила строку
- `t_ctid` - (0,2) - страница 0, позиция 2 (текущее местоположение)

#### Задача 2: Анализ системной таблицы

**Системные таблицы** - это специальные таблицы, в которых PostgreSQL хранит метаданные о всех объектах базы данных.

``` sql
SELECT ctid FROM pg_class WHERE relname = 'pg_class';
SELECT t_xmin, t_xmax, t_ctid  FROM heap_page_items(get_raw_page('pg_class',0));
```

```
  ctid  
--------
 (7,65)
(1 row)
```
```

 t_xmin | t_xmax | t_ctid 
--------+--------+--------
        |        | 
    778 |    778 | (0,5)
    778 |    788 | (0,3)
    778 |    788 | (0,4)
    778 |    788 | (0,5)
    778 |    788 | (0,6)
```
**ctid = (7, 65)** - 7 номер блока, 65 номер строки в блоке

#### Задача 3: ON_ERROR_ROLLBACK

Тестирование без ON_ERROR_ROLLBACK
``` sql
\set ON_ERROR_ROLLBACK on
BEGIN;
CREATE TABLE err_demo(id int PRIMARY KEY);
INSERT INTO err_demo VALUES (1);
INSERT INTO err_demo VALUES (1);  
INSERT INTO err_demo VALUES (2);    
COMMIT;
SELECT * FROM err_demo;  
```

```
BEGIN
   
COMMIT;

CREATE TABLE

INSERT 0 1

ERROR:  duplicate key value violates unique constraint "err_demo_pkey"
DETAIL:  Key (id)=(1) already exists.

INSERT 0 1

COMMIT

 id 
----
  1
  2
(2 rows)
```

### Модуль 4:  Снимки данных (Snapshots)

#### Задача 1: Видимость удаленной строки

**Сеанс 1 (Транзакция A):**
``` sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT pg_current_snapshot() as snapshot_a; -- Запоминаем снимок
SELECT * FROM snapshot_test; -- Видим строку 1
```

```
| snapshot_a |
|------------|
| 840:840:   |
(1 rows)

| id |
|----|
| 1  |
(1 rows)
```
**`pg_current_snapshot()`:**  
Возвращает строку формата `xmin:xmax:xip_list`:
- `xmin` - самая ранняя активная транзакция
- `xmax` - следующий ID транзакции, который будет назначен
- `xip_list` - список активных транзакций

**Сеанс 2:**
``` sql
BEGIN;
DELETE FROM snapshot_test;
COMMIT; -- Строка удалена и изменения подтверждены
```

```
BEGIN

DELETE 1

COMMIT
```

**Сеанс 3 (Транзакция B):**
``` sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT pg_current_snapshot() as snapshot_b; -- Запоминаем снимок
SELECT * FROM snapshot_test;
```

```
BEGIN

| snapshot_b |
|------------|
| 841:841:   |
(1 rows)

| id |
|----|
(0 rows)
```

**Анализ снимков и системных полей удаленной строки:**
``` sql
SELECT pg_snapshot_xip('840:840:');
SELECT pg_snapshot_xip('841:841:');
SELECT
     pg_snapshot_xmin('840:840:') as xmin_a,
     pg_snapshot_xmax('840:840:') as xmax_a,
     pg_snapshot_xmin('841:841:') as xmin_b,
     pg_snapshot_xmin('841:841:') as xmax_b;
SELECT lp, t_xmin, t_xmax, t_ctid 
 FROM heap_page_items(get_raw_page('snapshot_test', 0));
```

```
| pg_snapshot_xip |
|-----------------|
(0 rows)

| pg_snapshot_xip |
|-----------------|
(0 rows)

| xmin_a | xmax_a | xmin_b | xmax_b |
|--------+--------+--------+--------|
| 840    | 840    | 841    | 841    |
(1 rows)

| lp | t_xmin | t_xmax | t_ctid |
|----+--------+--------+--------|
| 1  | 829    | 830    | (0,1)  |
| 2  | 831    | 832    | (0,2)  |
| 3  | 835    | 837    | (0,3)  |
| 4  | 839    | 840    | (0,4)  |
(4 rows)
```

#### Задача 2: Снимки в функциях

Создание функций и подгтовка данных:
``` sql
CREATE TABLE test_data (id SERIAL PRIMARY KEY, value TEXT);
INSERT INTO test_data (value) VALUES ('initial value');
-- Функция для получения текущего снимка
CREATE OR REPLACE FUNCTION get_snapshot_info()
RETURNS TEXT AS $$
BEGIN
    RETURN pg_current_snapshot() || ' | txid: ' || txid_current();
END;
$$ LANGUAGE plpgsql;

-- STABLE функция
CREATE OR REPLACE FUNCTION stable_get_data()
RETURNS TABLE(id INT, value TEXT, snapshot TEXT) AS $$
BEGIN
    RETURN QUERY 
    SELECT t.id, t.value, get_snapshot_info() 
    FROM test_data t;
END;
$$ LANGUAGE plpgsql STABLE;

CREATE OR REPLACE FUNCTION volatile_get_data()
RETURNS TABLE(id INT, value TEXT, snapshot TEXT) AS $$
BEGIN
    RETURN QUERY 
    SELECT t.id, t.value, get_snapshot_info() 
    FROM test_data t;
END;
$$ LANGUAGE plpgsql VOLATILE;
```

###### Read Committed
**Сеанс 1:**
``` sql
BEGIN;
UPDATE test_data SET value = 'updated in tx 1' WHERE id = 1;
```

```
BEGIN
UPDATE 1
```

**Сеанс 2:**
``` sql
BEGIN ISOLATION LEVEL READ COMMITTED;
-- Первый вызов
SELECT * FROM stable_get_data();
SELECT * FROM volatile_get_data();
```

```
BEGIN
| id | value         | snapshot             |
|----+---------------+----------------------|
| 1  | initial value | 847:847: | txid: 848 |
(1 rows)

| id | value         | snapshot             |
|----+---------------+----------------------|
| 1  | initial value | 847:847: | txid: 848 |
(1 rows)
```

**Сеанс 1:** 
``` sql
COMMIT;
```

**Сеанс 2:**
```sql 
-- Второй вызов после коммита
SELECT * FROM stable_get_data(); 
SELECT * FROM volatile_get_data();
COMMIT;
```
	
```
| id | value           | snapshot             |
|----+-----------------+----------------------|
| 1  | updated in tx 1 | 848:848: | txid: 848 |
(1 rows)

| id | value           | snapshot             |
|----+-----------------+----------------------|
| 1  | updated in tx 1 | 848:848: | txid: 848 |
(1 rows)

COMMIT
```

###### Repeatable Read
**Сеанс 1 (изменяет данные):**
``` sql
BEGIN;
UPDATE test_data SET value = 'updated in tx 2' WHERE id = 1;
```

**Сеанс 2 (тестируем функции):**
``` sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
-- Первый вызов
SELECT * FROM stable_get_data();
SELECT * FROM volatile_get_data();
-- Сеанс 1 коммитит изменения
SELECT * FROM stable_get_data();
SELECT * FROM volatile_get_data();
COMMIT;
```

```
BEGIN
| id | value           | snapshot             |
|----+-----------------+----------------------|
| 1  | updated in tx 1 | 849:849: | txid: 850 |
(1 rows)

| id | value           | snapshot             |
|----+-----------------+----------------------|
| 1  | updated in tx 1 | 849:849: | txid: 850 |
(1 rows)

| id | value           | snapshot             |
|----+-----------------+----------------------|
| 1  | updated in tx 1 | 849:849: | txid: 850 |
(1 rows)

| id | value           | snapshot             |
|----+-----------------+----------------------|
| 1  | updated in tx 1 | 849:849: | txid: 850 |
(1 rows)
COMMIT
```

Результаты:
- **STABLE функции** используют снимок транзакции
- **VOLATILE функции** могут видеть новые изменения даже в Repeatable Read
- На **Read Committed** обе функции видят новые изменения

#### Задача 3: Экспорт/импорт списка

Подготовка данных:
``` sql
TRUNCATE phantom_test;
INSERT INTO phantom_test VALUES (1), (2), (3);
```

**Транзакция 1 - эскпорт снимка**
**Сеанс 1**:
``` sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM phantom_test; -- Видим (1,2,3)
SELECT pg_export_snapshot() as snapshot_id;
```

```
BEGIN
| id |
|----|
| 1  |
| 2  |
| 3  |
(3 rows)

| snapshot_id         |
|---------------------|
| 00000003-00006F7A-1 |
(1 rows)
```

 **Транзакция 2 - внести изменения**
 **Сеанс 2:**
 ``` sql
INSERT INTO phantom_test VALUES (100);
UPDATE phantom_test SET id = id * 10 WHERE id = 1;
COMMIT;
-- Проверяем текущее состояние
SELECT * FROM phantom_test; -- Видим (10,2,3,100)
```

```
INSERT 0 1
UPDATE 1

| id  |
|-----|
| 2   |
| 3   |
| 100 |
| 10  |
(4 rows)
```

**Транзакция 3 - импорт снимка**
**Сеанс 3:**
```sql
BEGIN ISOLATION LEVEL REPEATABLE READ;
-- Импортируем снимок из транзакции 1
SET TRANSACTION SNAPSHOT '00000003-00006F7A-1';
SELECT * FROM phantom_test;
COMMIT;
```

```
BEGIN
SET
| id|
|----|
| 1  |
| 2  |
| 3  |
(3 rows)
COMMIT
```

Результаты:
- **Транзакция 3** увидит данные в состоянии на момент экспорта снимка: (1,2,3)
- Изменения из **транзакции 2** (10,100) будут невидимы