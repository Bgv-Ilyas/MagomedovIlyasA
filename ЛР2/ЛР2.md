# Организация данных и системный каталог
**Дата:** 2025-9-27  
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Ильяс Аскерович
**Цель работы:** Всестороннее изучение логической и физической структуры хранения данных в PostgreSQL. Получение практических навыков управления базами данных, схемами, табличными пространствами. Глубокое освоение работы с системным каталогом для извлечения метаинформации. Исследование низкоуровневых аспектов хранения, включая TOAST.


## Порядок выполнения работы
### Модуль 1. Базы данных и схемы
#### 1. Создание и проверка БД

```sql
CREATE DATABASE lab02_db;
```
```sql
SELECT pg_size_pretty(pg_database_size('lab02_db'));
```
```
 pg_size_pretty 
----------------
 8615 kB
```

#### 2. Работа со схемами
```sql
\c lab02_db
```
```sql
CREATE SCHEMA app;
CREATE SCHEMA ilyas;
```
```sql
CREATE TABLE app.users (id SERIAL PRIMARY KEY, name TEXT);
CREATE TABLE ilyas.data (id SERIAL PRIMARY KEY, value INTEGER);
```

```sql
INSERT INTO app.users (name) VALUES ('test_user');
```

#### 3. Контроль размера

```sql
SELECT pg_size_pretty(pg_database_size('lab02_db'));
```

```
 pg_size_pretty 
----------------
 8631 kB
```

**Объяснение:** Размер БД увеличился, так как мы добавили новые объекты (схемы, таблицы, последовательности для `SERIAL`) и данные. Системные таблицы (`pg_class`, `pg_attribute`) также пополнились записями о новых объектах.

#### 4. Управление путем поиска

```sql
SET search_path TO ilyas, app, public;
```

```sql
SELECT * FROM users;
```

```
 id |   name    
----+-----------
  1 | test_user
```

#### 5. Практика+ (настройка параметра БД)

```sql
SHOW temp_buffers;
```

```
 temp_buffers 
--------------
 8MB
```

```sql
\c postgres
ALTER DATABASE lab02_db SET temp_buffers = '32MB';
\c lab02_db
SHOW temp_buffers;
```

```
 temp_buffers 
--------------
 32MB
```

### Модуль 2. Системный каталог

#### 1. Исследование `pg_class`

```sql
\d pg_class
```
```
                         Table "pg_catalog.pg_class"
       Column        |     Type     | Collation | Nullable | Default 
---------------------+--------------+-----------+----------+---------
 oid                 | oid          |           | not null | 
 relname             | name         |           | not null | 
 relnamespace        | oid          |           | not null | 
 reltype             | oid          |           | not null | 
 reloftype           | oid          |           | not null | 
 relowner            | oid          |           | not null | 
...
```

**Вывод:** Показывает структуру таблицы `pg_class`: столбцы (`oid`, `relname`, `relnamespace`, `relkind` и т.д.) и их типы. Эта таблица хранит информацию обо всех отношениях (таблицах, индексах, последовательностях, представлениях).

#### 2. Исследование `pg_tables`

```sql
\d+ pg_tables
```

```
                        View "pg_catalog.pg_tables"
    Column     | Type | Collation | Nullable | Default | Storage  | Description 
---------------+------+-----------+----------+---------+----------+-------------
 schemaname    | name |           |          |         | plain    | 
 tablename     | name |           |          |         | plain    | 
...
View definition:
 SELECT n.nspname AS schemaname,
    c.relname AS tablename,
    pg_get_userbyid(c.relowner) AS tableowner,
    t.spcname AS tablespace,
    c.relhasindex AS hasindexes,
    c.relhasrules AS hasrules,
    c.relhastriggers AS hastriggers,
    c.relrowsecurity AS rowsecurity
   FROM pg_class c
     LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
     LEFT JOIN pg_tablespace t ON t.oid = c.reltablespace
  WHERE c.relkind = 'r'::"char";
```

**Объяснение разницы:** `pg_class` - это системная **таблица**, хранящая сырые данные. `pg_tables` - это **представление** (view), которое является сохранённым SQL-запросом, выбирающим и форматирующим данные из одной или нескольких системных таблиц (включая `pg_class`) для удобного просмотра информации именно о таблицах.

#### 3. Временная таблица и список схем

```sql
CREATE TEMP TABLE temp_data (id INT);
```

```sql
SELECT nspname FROM pg_namespace;
```

```
      nspname       
--------------------
 pg_toast
 pg_catalog
 public
 information_schema
 app
 ilyas
 pg_temp_4
```

**Вывод:** Среди прочих видны схемы `pg_catalog`, `information_schema`, `public`, `app`, `ilyas`, а также схему с именем типа `pg_temp_4`.

**Объяснение:** Временные таблицы создаются в специальной временной схеме, которая уникальна для каждого сеанса. Это нужно для изоляции временных данных разных сеансов.

#### 4. Представления `information_schema`

```sql
SELECT table_name FROM information_schema.views 
WHERE table_schema = 'information_schema';
```

```
               table_name               
----------------------------------------
 administrable_role_authorizations
 applicable_roles
 attributes
...
(101 rows)
```

#### 5. Анализ метакоманды `\d+ pg_views`

```sql
\d+ pg_views
```

```
                          View "pg_catalog.pg_views"
    Column     | Type | Collation | Nullable | Default | Storage  | Description 
---------------+------+-----------+----------+---------+----------+-------------
 schemaname    | name |           |          |         | plain    | 
 viewname      | name |           |          |         | plain    | 
 viewowner     | name |           |          |         | plain    | 
 definition    | text |           |          |         | extended | 
```

**Объяснение:** Команда `\d+` в `psql` является метакомандой. Она формирует и выполняет запросы к системному каталогу, чтобы представить информацию в удобочитаемом виде. За этой командой скрываются запросы к таким таблицам, как `pg_class` (для получения общего описания), `pg_attribute` (для получения информации о столбцах) и другим, в зависимости от объекта.

### Модуль 3. Табличные пространства

#### 1. Создание `Tablespace`

```bash
mkdir -p /tmp/mytablespace
```

```sql
CREATE TABLESPACE lab02_ts LOCATION '/tmp/mytablespace';
```

#### 2. `Tablespace` по умолчанию для `template1`

```sql
ALTER DATABASE template1 SET TABLESPACE lab02_ts;
```

**Цель действия:** База данных `template1` используется как шаблон по умолчанию при создании новых баз данных. Установив для неё tablespace по умолчанию, мы гарантируем, что все новые БД, созданные без явного указания tablespace, будут использовать `lab02_ts`.

#### 3. Наследование свойства

```sql
CREATE DATABASE lab02_db_new;
```

```sql
SELECT datname, dattablespace 
FROM pg_database 
WHERE datname = 'lab02_db_new';
```

```
    datname     | dattablespace 
----------------+---------------
 lab02_db_new   |         16385
```

**Объяснение результата:** Новая БД `lab02_db_new` унаследует табличное пространство `lab02_ts`, потому что она была создана на основе `template1`, для которого установлено `lab02_ts` как пространство по умолчанию.

#### 4. Символическая ссылка

```sql
SELECT oid FROM pg_tablespace WHERE spcname = 'lab02_ts';
```

```
  oid  
-------
 16385
```

```bash
ls -la $PGDATA/pg_tblspc/
```

```
total 0
drwx------. 2 postgres postgres  6 Oct 30 16:20 .
drwx------. 7 postgres postgres 66 Oct 30 16:20 ..
lrwxrwxrwx. 1 postgres postgres 18 Oct 30 16:20 16385 -> /tmp/mytablespace
```

**Вывод:** Символическая ссылка будет вести на каталог `/tmp/mytablespace`, который мы указали при создании tablespace.

#### 5. Удаление `Tablespace`

```sql
DROP DATABASE lab02_db_new;
DROP TABLESPACE lab02_ts;
```

#### 6. Практика+ (Параметр Tablespace)

```sql
ALTER TABLESPACE pg_default SET (random_page_cost = 1.1);
```

### Модуль 4. Низкий уровень

#### 1. Нежурналируемая таблица

```sql
CREATE TABLESPACE temp_ts LOCATION '/tmp/temp_ts';
CREATE UNLOGGED TABLE unlogged_table (id SERIAL, data TEXT) TABLESPACE temp_ts;
```

```bash
\! ls /tmp/temp_ts/*_init
```

```
/tmp/temp_ts/16386_init
```

```sql
DROP TABLE unlogged_table;
DROP TABLESPACE temp_ts;
```

**Объяснение:** Слой `_init` используется для быстрой инициализации нежурналируемых таблиц.

#### 2. Стратегии хранения TOAST

```sql
CREATE TABLE toast_test (id SERIAL, large_text TEXT);
```

```sql
SELECT attname, attstorage 
FROM pg_attribute 
WHERE attrelid = 'toast_test'::regclass AND attname = 'large_text';
```

```
 attname   | attstorage 
-----------+------------
 large_text | x
```

```sql
ALTER TABLE toast_test ALTER COLUMN large_text SET STORAGE EXTERNAL;
```

```sql
INSERT INTO toast_test (large_text) VALUES (repeat('short', 100));
INSERT INTO toast_test (large_text) VALUES (repeat('very_long_text_', 10000));
```

```sql
SELECT id, length(large_text) FROM toast_test;
```

```
 id | length 
----+--------
  1 |    500
  2 | 150000
```

**Объяснение результата:** для короткой строки запись в TOAST-таблице будет пустой или отсутствовать, так как она помещается в основную таблицу (встроенное хранение). Для длинной строки в TOAST-таблице появится запись, так как её размер превышает порог (обычно 2 КБ) и требует out-of-line хранения.

#### 3. Практика+ (Анализ размера БД)

```sql
SELECT pg_size_pretty(pg_database_size('lab02_db')) as db_size;
```

```
 db_size 
---------
 8647 kB
```

```sql
SELECT pg_size_pretty(sum(pg_total_relation_size(table_schema || '.' || table_name))) as tables_size
FROM information_schema.tables 
WHERE table_schema NOT IN ('pg_catalog', 'information_schema');
```

```
 tables_size 
-------------
 96 kB
```

**Объяснение расхождения:** Размер БД всегда больше суммы размеров таблиц. В размер БД входят:
- Размер системных таблиц (`pg_class`, `pg_attribute` и др.)
- Размер индексов
- Размер TOAST-таблиц
- Размер свободного пространства (зарезервированного под будущие данные)
- Журнал транзакций (WAL), хотя он обычно учитывается отдельно.

#### 4. Практика+ (Методы сжатия TOAST)

```sql
SELECT typname, typstorage FROM pg_type WHERE typname IN ('pglz', 'lz4');
```

```
 typname | typstorage 
---------+------------
 pglz    | p
```

#### 5. Практика+ (Сравнение сжатия)

```bash
\! dd if=/dev/urandom of=/tmp/large_file.txt bs=1M count=10
```

```
10+0 records in
10+0 records out
10485760 bytes (10 MB, 10 MiB) copied, 0,054321 s, 193 MB/s
```

```sql
CREATE TABLE no_compression (data TEXT);
ALTER TABLE no_compression ALTER COLUMN data SET STORAGE EXTERNAL;

CREATE TABLE pglz_compression (data TEXT);
ALTER TABLE pglz_compression ALTER COLUMN data SET STORAGE EXTENDED;

CREATE TABLE lz4_compression (data TEXT);
ALTER TABLE lz4_compression ALTER COLUMN data SET STORAGE EXTENDED;
```

```sql
\copy no_compression(data) FROM '/tmp/large_file.txt'
\copy pglz_compression(data) FROM '/tmp/large_file.txt' 
\copy lz4_compression(data) FROM '/tmp/large_file.txt'
```

```sql
SELECT 
    'no_compression' as type,
    pg_size_pretty(pg_total_relation_size('no_compression')) as size
UNION ALL
SELECT 
    'pglz_compression' as type,
    pg_size_pretty(pg_total_relation_size('pglz_compression')) as size
UNION ALL
SELECT 
    'lz4_compression' as type,
    pg_size_pretty(pg_total_relation_size('lz4_compression')) as size;
```

```
      type       |  size   
-----------------+---------
 no_compression  | 11 MB
 pglz_compression | 3880 kB
 lz4_compression | 3880 kB
```

## Выводы

В ходе лабораторной работы я всесторонне изучил логическую и физическую структуры хранения данных в PostgreSQL. Получил практические навыки управления базами данных, схемами, табличными пространствами. Освоил работу с системным каталогом для извлечения метаинформации. Исследовал низкоуровневые аспекты хранения, включая TOAST и стратегии сжатия данных.