# Лабораторная работа №08: Резервное копирование и управление доступом

**Дата:** 16.11.2025  
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Ильяс Аскерович  

## Цель работы
Освоить методы резервного копирования и восстановления данных в PostgreSQL, включая логическое и физическое копирование, а также углубить навыки управления правами доступа пользователей.

## Теоретическая часть
- **Логическое резервное копирование:** Выполняется утилитами `pg_dump` и `pg_dumpall`. Создаёт дампы SQL-команд для восстановления структуры и данных. Гибкое, но может быть медленным для больших БД.
- **Физическое резервное копирование:** Копирование файлов данных кластера с помощью `pg_basebackup`. Быстрее, но требует архивации WAL для восстановления на момент времени (PITR).
- **WAL-архивация:** Непрерывное сохранение сегментов WAL. Позволяет восстанавливать данные на любой момент времени после создания базовой резервной копии.
- **Обновление сервера:** Процесс миграции данных на новую мажорную версию PostgreSQL, часто с использованием логического дампа/восстановления.

## Практическая часть

### Модуль 1: Управление доступом (Повторение и закрепление)
#### 1. Настройка привилегий

```sql
-- Создание БД и ролей
CREATE DATABASE access_db_08;
CREATE ROLE writer_08 WITH LOGIN PASSWORD 'writer_pass';
CREATE ROLE reader_08 WITH LOGIN PASSWORD 'reader_pass';
\c access_db_08
REVOKE ALL ON SCHEMA public FROM PUBLIC;
GRANT CREATE, USAGE ON SCHEMA public TO writer_08;
GRANT USAGE ON SCHEMA public TO reader_08;
-- Создание таблицы и тестовых данных
CREATE TABLE test_data (id INT, content TEXT);
INSERT INTO test_data VALUES (1, 'test row 1'), (2, 'test row 2');
-- Настройка привилегий
ALTER DEFAULT PRIVILEGES FOR ROLE writer_08 IN SCHEMA public
GRANT SELECT ON TABLES TO reader_08;
```
```
CREATE DATABASE
CREATE ROLE
CREATE ROLE
You are now connected to database "access_db_08" as user "postgres".
REVOKE
GRANT
GRANT
CREATE TABLE
INSERT 0 2
ALTER DEFAULT PRIVILEGES
```

#### 2. Настройка аутентификации

```sql
-- Создание пользователей
CREATE ROLE alice LOGIN;
CREATE ROLE bob LOGIN;
```
```
CREATE ROLE
CREATE ROLE
```

``` sql
local all alice peer map=users_map
local all bob peer map=users_map
```
``` sql
SELECT pg_reload_conf();
```
```
 pg_reload_conf 
----------------
 t
(1 row)
```

### Модуль 2: Логическое резервное копирование
#### 1. Простой дамп и восстановление

```sql
-- Создание БД и таблицы
CREATE DATABASE backup_db;
\c backup_db
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    position VARCHAR(100)
);
INSERT INTO employees (name, position) VALUES 
('Иван Иванов', 'Разработчик'),
('Мария Петрова', 'Аналитик'),
('Алексей Сидоров', 'Тестировщик');
```
```
CREATE DATABASE
You are now connected to database "backup_db" as user "postgres".
CREATE TABLE
INSERT 0 3
```

```bash
pg_dump -U postgres backup_db > backup_db_dump.sql
```

```sql
\c postgres
DROP DATABASE backup_db;
```
```
You are now connected to database "postgres" as user "postgres".
DROP DATABASE
```

```bash
createdb -U postgres backup_db
psql -U postgres backup_db < backup_db_dump.sql
```
```sql
\c backup_db
SELECT * FROM employees;
```
```
You are now connected to database "backup_db" as user "postgres".
 id |      name       |   position    
----+-----------------+---------------
  1 | Иван Иванов     | Разработчик
  2 | Мария Петрова   | Аналитик
  3 | Алексей Сидоров | Тестировщик
(3 rows)
```
#### 2. Параллельный дамп

```sql
-- Создание нескольких БД
CREATE DATABASE db1;
CREATE DATABASE db2;
\c db1
CREATE TABLE table1 (id INT);
INSERT INTO table1 VALUES (1), (2);
\c db2
CREATE TABLE table2 (id INT, data TEXT);
INSERT INTO table2 VALUES (1, 'text1'), (2, 'text2');
```
```
CREATE DATABASE
CREATE DATABASE
You are now connected to database "db1" as user "postgres".
CREATE TABLE
INSERT 0 2
You are now connected to database "db2" as user "postgres".
CREATE TABLE
INSERT 0 2
```

```bash
pg_dumpall -U postgres --globals-only > globals_dump.sql
```
```bash
pg_dump -U postgres -j 2 -F d -f parallel_backup db1 db2 
```

#### 3. Восстановление кластера

```bash
# Создание дампа всего кластера
pg_dumpall -U postgres > full_cluster_dump.sql
# Восстановление на "другом сервере"
createdb -U postgres restored_cluster
psql -U postgres -f full_cluster_dump.sql postgres
```

### Модуль 3: Физическое резервное копирование и PITR
#### 1. Базовая резервная копия

```sql
-- Создание табличного пространства
CREATE TABLESPACE my_tablespace LOCATION '/Users/ilyas/PostgreSQL/tablespace';
-- Создание БД в табличном пространстве
CREATE DATABASE ts_db TABLESPACE my_tablespace;
\c ts_db
CREATE TABLE ts_table (id INT, info TEXT);
INSERT INTO ts_table VALUES (1, 'Data in tablespace');
```
```
CREATE TABLESPACE
CREATE DATABASE
You are now connected to database "ts_db" as user "postgres".
CREATE TABLE
INSERT 0 1
```

```bash
pg_basebackup -U postgres -D /Users/ilyas/PostgreSQL/backup -Ft -z -Xs -P
```
```
pg_basebackup: initiating base backup, waiting for checkpoint to complete
pg_basebackup: checkpoint completed
pg_basebackup: write-ahead log start point: 0/3000028 on timeline 1
pg_basebackup: executing pg_wal_backup_start
pg_basebackup: write-ahead log end point: 0/3000100
pg_basebackup: waiting for background process to finish streaming ...
pg_basebackup: syncing data to disk ...
pg_basebackup: base backup completed
```

## Выводы  
1. Логическое резервное копирование с помощью `pg_dump` и `pg_dumpall` предоставляет гибкий способ создания резервных копий отдельных баз данных или всего кластера, позволяя выбирать конкретные объекты для резервирования и восстанавливать данные на разных версиях PostgreSQL.  
2. Физическое резервное копирование с использованием `pg_basebackup` обеспечивает более быстрое создание полных копий кластера, но требует настройки WAL-архивации для реализации восстановления на момент времени (PITR).  
3. WAL-архивация является критически важным компонентом для обеспечения надежности СУБД PostgreSQL, позволяя восстанавливать данные на любой момент времени после создания базовой резервной копии. 
4. Обновление версий PostgreSQL с использованием логического дампа является надежным методом миграции данных между мажорными версиями, обеспечивая совместимость и целостность данных.
5. Управление доступом остается фундаментальным аспектом администрирования баз данных, и повторение этих навыков способствует их закреплению и углубленному пониманию.
6. Все задания выполнены, результаты проверены и задокументированы.