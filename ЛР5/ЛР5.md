### Техобслуживание: Надежность: Журнал предзаписи (WAL)

**Дата:** 2025-11-01 
**Семестр:** 4 курс 1 полугодие – 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Магомедов Ильяс Аскерович

## Цель работы
Изучить работу буферного кеша и механизма журналирования предзаписи (WAL) в
PostgreSQL. Получить практические навыки управления контрольными точками, анализа журнальных
записей, настройки параметров WAL и исследования процессов восстановления после сбоев.

## Теоретическая часть
Буферный кеш: Область общей памяти для кэширования страниц данных, считываемых с диска. Измененные ("грязные") буферы периодически сбрасываются на диск.
Контрольная точка (Checkpoint): Процесс принудительной записи всех "грязных" буферов надиск. Ограничивает объем WAL, необходимый для восстановления.
Журнал предзаписи (WAL): Циклический журнал, в который записываются все изменения
данных перед тем, как они попадут в основные файлы данных. Обеспечивает надежность ивозможность восстановления после сбоя.
Восстановление: Процесс применения WAL-записей, созданных после последней контрольной точки, к данным на диске для приведения их в согласованное состояние.


### Модуль 1: Процессы и режимы остановки
#### Задача 1: Поиск процессов
```bash
ps -ef | grep -E "post(gres|master)|checkpointer|writer|wal" | grep -v grep
```
```
/main -c config_file=/etc/postgresql/16/main/postgresql.conf
postgres     797     787  0 08:34 ?        00:00:00 postgres: 16/main: checkpointer 
postgres     798     787  0 08:34 ?        00:00:00 postgres: 16/main: background writer 
postgres     977     787  0 08:34 ?        00:00:00 postgres: 16/main: walwriter 
postgres     978     787  0 08:34 ?        00:00:02 postgres: 16/main: autovacuum launcher 
postgres     979     787  0 08:34 ?        00:00:00 postgres: 16/main: logical replication launcher 
student     6148    1601  0 08:46 pts/0    00:00:00 /usr/lib/postgresql/16/bin/psql
```

#### Задача 2: Остановка Fast
```bash
sudo pg_ctlcluster 16 main stop -m fast
sudo pg_ctlcluster 16 main start
sudo tail -n 200 /var/log/postgresql/postgresql-16-main.log
```

```
2025-11-01 08:53:20.243 MSK [797] LOG:  checkpoint starting: shutdown immediate
2025-11-01 08:53:20.250 MSK [797] LOG:  checkpoint complete: wrote 0 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.001 s, sync=0.001 s, total=0.009 s; sync files=0, longest=0.000 s, average=0.000 s; distance=0 kB, estimate=22877 kB; lsn=0/64E8C0F0, redo lsn=0/64E8C0F0
```


#### Задача 3: Остановка Immediate
```bash
sudo pg_ctlcluster 16 main stop -m immediate
sudo pg_ctlcluster 16 main start
sudo tail -n 200 /var/log/postgresql/postgresql-16-main.log
```

```
2025-11-01 10:06:08.573 MSK [38667] LOG:  database system was not properly shut down; automatic recovery in progress
2025-11-01 10:06:08.786 MSK [38667] LOG:  redo starts at 0/5837B058
2025-11-01 10:06:08.984 MSK [38667] LOG:  invalid record length at 0/5837B058: expected at least 24, got 0
2025-11-01 10:06:09.345 MSK [38667] LOG:  redo done at 0/5837B058 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
2025-11-01 10:06:09.563 MSK [38666] LOG:  checkpoint starting: end-of-recovery immediate wait
2025-11-01 10:06:12.351 MSK [39813] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.003 s, sync=0.002 s, total=0.013 s; sync files=2, longest=0.001 s, average=0.001 s; distance=0 kB, estimate=0 kB; lsn=0/5837B058, redo lsn=0/5837B058
```


Выводы:
 **1. Идентификация процессов PostgreSQL**
С помощью команды `ps -ef | grep -E` были успешно идентифицированы ключевые процессы СУБД:
- **`checkpointer`** - процесс контрольных точек
- **`background writer`** - фоновый процесс записи
- **`walwriter`** - процесс записи в WAL-журнал

 **2. Сравнение режимов остановки**
Были проведены эксперименты с двумя режимами остановки:
**Режим FAST (чистое завершение):**
- В логе зафиксирована контрольная точка перед завершением: `checkpoint complete`
- Сервер сообщил: `database system is shut down`
- При последующем запуске восстановление не потребовалось
- **Вывод:** Все "грязные" буферы были сброшены на диск, данные приведены в согласованное состояние

**Режим IMMEDIATE (аварийное завершение):**
- В логе зафиксированы критические сообщения:
  - `database system was not properly shut down`
  - `automatic recovery in progress`
- Несмотря на сообщение `redo is not required`, механизм восстановления был активирован
- **Вывод:** Сервер воспринял остановку как сбой и запустил процедуру восстановления

### Модуль 2:  Буферный кеш и контрольные точки
#### Задача 1: Анализ размера

``` sql
CREATE TABLE wal_test (id INT, data TEXT);

INSERT INTO wal_test 
SELECT generate_series(1,10000), 
       md5(random()::text);
SELECT count(*) FROM wal_test;
SELECT current_setting('block_size') AS block_size_bytes;
SELECT pg_relation_size('wal_test') AS table_size_bytes;
SELECT 
    pg_relation_size('wal_test') AS size_bytes,
    pg_relation_size('wal_test') / current_setting('block_size')::int AS size_blocks;   
CREATE EXTENSION IF NOT EXISTS pg_buffercache;
SELECT 
    COUNT(*) AS buffers_used,
    COUNT(*) * current_setting('block_size')::int AS memory_used_bytes
FROM pg_buffercache 
WHERE relfilenode = pg_relation_filenode('wal_test');
```

```
CREATE TABLE

INSERT 0 10000

 count 
-------
 10000
(1 row)

 block_size_bytes 
------------------
 8192
(1 row)

 table_size_bytes 
------------------
           688128
(1 row)

 size_bytes | size_blocks 
------------+-------------
     688128 |          84
(1 row)

CREATE EXTENSION
 buffers_used | memory_used_bytes 
--------------+-------------------
           88 |            720896
(1 row)
```

#### Задача 2: Грязные буферы и контрольная точка
``` sql
SELECT buffers_clean, buffers_backend, buffers_backend_fsync, buffers_alloc FROM pg_stat_bgwriter;
SELECT COUNT(*) AS total_buffers, SUM(CASE WHEN isdirty THEN 1 ELSE 0 END) AS dirty_buffers FROM pg_buffercache 
WHERE relfilenode = pg_relation_filenode('wal_test');
UPDATE wal_test SET data = md5(random()::text) WHERE id <= 1000;
SELECT COUNT(*) AS total_buffers, SUM(CASE WHEN isdirty THEN 1 ELSE 0 END) AS dirty_buffers FROM pg_buffercache 
WHERE relfilenode = pg_relation_filenode('wal_test');
CHECKPOINT;
SELECT COUNT(*) AS total_buffers, SUM(CASE WHEN isdirty THEN 1 ELSE 0 END) AS dirty_buffers FROM pg_buffercache 
WHERE relfilenode = pg_relation_filenode('wal_test');
```

```
 buffers_clean | buffers_backend | buffers_backend_fsync | buffers_alloc 
---------------+-----------------+-----------------------+---------------
             0 |               0 |                     0 |           366
(1 row)

 total_buffers | dirty_buffers 
---------------+---------------
            88 |            85
(1 row)

UPDATE 1000

 total_buffers | dirty_buffers 
---------------+---------------
            96 |            22
(1 row)

CHECKPOINT

 total_buffers | dirty_buffers 
---------------+---------------
            96 |             0
(1 row)
```

1. **Механизм контрольных точек** эффективно выполняет свою основную функцию - принудительную запись всех измененных данных из оперативной памяти на диск. После команды `CHECKPOINT` количество грязных буферов для тестовой таблицы уменьшилось до нуля.
2. **Фоновые процессы PostgreSQL** (background writer) работают непрерывно - даже до выполнения контрольной точки часть грязных буферов уже была записана на диск, что объясняет уменьшение их количества после операции UPDATE.
3. **Буферный кеш сохраняет данные** после контрольной точки, но теперь все буферы помечаются как "чистые", поскольку их содержимое синхронизировано с данными на диске.
4. **Контрольная точка ограничивает объем WAL**, необходимый для восстановления, поскольку гарантирует, что все изменения до определенного момента физически записаны на диск, что подтверждает ее критическую роль в обеспечении надежности СУБД.

#### Задача 3: Предварительное чтение (pg_prewarm)
```sql
CREATE EXTENSION pg_prewarm;
SELECT pg_prewarm('wal_test');
```
```bash
sudo pg_ctlcluster 16 main restart
```
```sql
WITH rel AS (
  SELECT oid, pg_relation_filenode(oid) AS fn
  FROM pg_class WHERE relname = 'wal_test'
)
SELECT count(*) AS buffers
FROM pg_buffercache b
JOIN rel r
  ON b.reldatabase = (SELECT oid FROM pg_database WHERE datname = current_database())
 AND b.relfilenode = r.fn
 AND b.relforknumber = 0;
```

```
 pg_prewarm 
------------
2942
(1 row)
```
```text
 buffers 
---------
0
```

### Модуль 3:  Журнал предзаписи (WAL)
#### Задача 1: Размер WAL-записей
``` sql
SELECT pg_current_wal_lsn();
CREATE TABLE wal_lsn_test(
  id   serial PRIMARY KEY,
  txt  text
);
BEGIN;
INSERT INTO wal_lsn_test VALUES (1, 'text1');
INSERT INTO wal_lsn_test VALUES (2, 'text2');
INSERT INTO wal_lsn_test VALUES (3, 'text3');
COMMIT;
SELECT pg_current_wal_lsn() - '0/69328088'::pg_lsn;
```

```
pg_current_wal_lsn 
--------------------
 0/69328088
(1 row)

CREATE TABLE

BEGIN

INSERT 0 1

INSERT 0 1

INSERT 0 1

COMMIT

column 
----------
   185888
(1 row)
```

#### Задача 2: Анализ WAL
``` sql
SELECT 
    pg_relation_size('wal_lsn_test') AS table_size,
    pg_relation_size('wal_lsn_test_pkey') AS index_size;
```

```
 table_size | index_size 
------------+------------
       8192 |      16384
(1 row)
```

**Анализ объема WAL-записей показал, что их размер значительно превышает объем самих данных по следующим причинам:**
1. **Метаданные операций:** WAL содержит не только пользовательские данные, но и служебную информацию - заголовки записей, идентификаторы транзакций, временные метки.
2. **Индексные операции:** При вставке данных в таблицу с первичным ключом создаются дополнительные WAL-записи для поддержания структуры B-дерева индекса.
3. **Механизм full_page_writes:** Для обеспечения защиты от частичных записей страниц при сбое питания, PostgreSQL записывает в WAL полные страницы при их первом изменении после контрольной точки.
4. **Системные операции:** Создание таблицы и индексов также генерирует WAL-записи в системных каталогах PostgreSQL.
Таким образом, объем WAL-записей отражает не только пользовательские данные, но и всю служебную информацию, необходимую для гарантированного восстановления целостности базы данных после сбоя.
#### Задача 3: Восстановление после сбоя
```sql
CREATE TABLE wal_crash_demo(id int PRIMARY KEY, note text);
INSERT INTO wal_crash_demo VALUES (1, 'text1');
COMMIT;
BEGIN;
UPDATE wal_crash_demo SET note = 'text_2' WHERE id = 1;       
```
```bash
sudo cat /var/lib/postgresql/16/main/postmaster.pid
sudo kill -9 61619
sudo pg_ctlcluster 16 main start
```
```sql
SELECT * FROM wal_crash_demo;   
```
```bash
sudo tail -n 200 /var/log/postgresql/postgresql-16-main.log     
```

```
CREATE TABLE

INSERT 0 1

WARNING:  there is no transaction in progress
COMMIT

BEGIN

UPDATE 1
 id | note  
----+-------
  1 | text1
(1 row)

2025-11-01 11:45:33.402 MSK [84783] LOG:  database system was interrupted; last known up at 2025-10-09 11:44:25 MSK
2025-11-01 11:45:34.365 MSK [84783] LOG:  database system was not properly shut down; automatic recovery in progress
2025-11-01 11:45:34.371 MSK [84783] LOG:  redo starts at 0/6937BF90
2025-11-01 11:45:34.371 MSK [84783] LOG:  invalid record length at 0/6937C090: expected at least 24, got 0
2025-11-01 11:45:34.371 MSK [84783] LOG:  redo done at 0/6937C058 system usage: CPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s
2025-11-01 11:45:34.379 MSK [84781] LOG:  checkpoint starting: end-of-recovery immediate wait
2025-11-01 11:45:34.390 MSK [84781] LOG:  checkpoint complete: wrote 3 buffers (0.0%); 0 WAL file(s) added, 0 removed, 0 recycled; write=0.003 s, sync=0.002 s, total=0.013 s; sync files=2, longest=0.001 s, average=0.001 s; distance=0 kB, estimate=0 kB; lsn=0/6937C090, redo lsn=0/6937C090
```
